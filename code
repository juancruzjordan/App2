import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:excel/excel.dart';
import 'package:flutter/animation.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:io';
import 'dart:convert';
import 'dart:typed_data';
import 'dart:async';
import 'package:intl/intl.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  SystemChrome.setSystemUIOverlayStyle(const SystemUiOverlayStyle(
    statusBarColor: Colors.transparent,
    statusBarIconBrightness: Brightness.dark,
  ));
  runApp(const ParteDiarioApp());
}

enum EnvioEstado { inicial, enviando, exitoso, fallido }
enum RolPersona { operadorChofer, otro }

class ParteDiarioApp extends StatelessWidget {
  const ParteDiarioApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Registro de Personal',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        colorScheme: const ColorScheme.light(
          primary: Color(0xFF0D47A1),
          secondary: Color(0xFFFFC107),
        ),
        fontFamily: 'Poppins',
        textTheme: const TextTheme(
          displayLarge: TextStyle(fontSize: 28, fontWeight: FontWeight.bold, color: Color(0xFF0D47A1)),
          displayMedium: TextStyle(fontSize: 24, fontWeight: FontWeight.w600),
          titleLarge: TextStyle(fontSize: 20, fontWeight: FontWeight.bold, color: Color(0xFF0D47A1)),
          bodyLarge: TextStyle(fontSize: 16, fontWeight: FontWeight.w500),
          bodyMedium: TextStyle(fontSize: 14),
          labelLarge: TextStyle(fontSize: 16, fontWeight: FontWeight.bold, color: Colors.white),
        ),
        inputDecorationTheme: const InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.all(Radius.circular(12)),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.all(Radius.circular(12)),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.all(Radius.circular(12)),
            borderSide: BorderSide(color: Color(0xFF0D47A1), width: 2)),
          filled: true,
          fillColor: Colors.white,
          contentPadding: EdgeInsets.symmetric(horizontal: 20, vertical: 18),
          labelStyle: TextStyle(color: Color(0xFF616161)),
        cardTheme: const CardTheme(
          elevation: 2,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(16))),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: const Color(0xFF0D47A1),
            foregroundColor: Colors.white,
            elevation: 2,
            shape: const RoundedRectangleBorder(
              borderRadius: BorderRadius.all(Radius.circular(12))),
            padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 24),
            textStyle: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              fontFamily: 'Poppins')))),
      home: const SplashScreen(),
      debugShowCheckedModeBanner: false);
  }
}

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _scaleAnimation;
  late Animation<double> _fadeAnimation;
  late Animation<Color?> _backgroundColorAnimation;
  late Animation<double> _textSlideAnimation;
  late Animation<double> _textFadeAnimation;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 2000),
      vsync: this);

    _scaleAnimation = Tween<double>(begin: 0.8, end: 1.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.0, 0.5, curve: Curves.easeOutBack)));

    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.3, 1.0, curve: Curves.easeIn)));

    _backgroundColorAnimation = ColorTween(
      begin: const Color(0xFFF5F5F5),
      end: const Color(0xFFE3F2FD)).animate(_controller);

    _textSlideAnimation = Tween<double>(begin: 30, end: 0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.5, 0.8, curve: Curves.easeOut)));

    _textFadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(
        parent: _controller,
        curve: const Interval(0.6, 1.0, curve: Curves.easeIn)));

    _controller.forward();

    Future.delayed(const Duration(seconds: 3), () {
      if (mounted) {
        Navigator.pushReplacement(
          context,
          PageRouteBuilder(
            transitionDuration: const Duration(milliseconds: 800),
            pageBuilder: (_, __, ___) => const MainTabsScreen(),
            transitionsBuilder: (_, animation, __, child) {
              return FadeTransition(
                opacity: animation,
                child: child);
            }));
      }
    });
  }

  Widget _buildLogoWidget() {
    try {
      return Image.asset(
        'assets/logo.png',
        filterQuality: FilterQuality.high,
        errorBuilder: (context, error, stackTrace) {
          return const Icon(Icons.construction, size: 100, color: Color(0xFF0D47A1));
        });
    } catch (e) {
      return const Icon(Icons.construction, size: 100, color: Color(0xFF0D47A1));
    }
  }

  @override
  Widget build(BuildContext context) {
    final screenHeight = MediaQuery.of(context).size.height;

    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Scaffold(
          backgroundColor: _backgroundColorAnimation.value,
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                ScaleTransition(
                  scale: _scaleAnimation,
                  child: FadeTransition(
                    opacity: _fadeAnimation,
                    child: SizedBox(
                      height: screenHeight * 0.3,
                      child: _buildLogoWidget()))),
                const SizedBox(height: 20),
                Transform.translate(
                  offset: Offset(0, _textSlideAnimation.value),
                  child: FadeTransition(
                    opacity: _textFadeAnimation,
                    child: Text(
                      'APP - REPORTE DIARIO',
                      style: TextStyle(
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                        color: const Color(0xFF0D47A1).withOpacity(_textFadeAnimation.value),
                        letterSpacing: 1.5,
                        shadows: [
                          Shadow(
                            blurRadius: 10,
                            color: Colors.black.withOpacity(0.1),
                            offset: const Offset(0, 2))
                        ])))),
                const SizedBox(height: 40),
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: const CircularProgressIndicator(
                    valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF0D47A1)),
                    strokeWidth: 3)),
                const SizedBox(height: 20),
                FadeTransition(
                  opacity: _fadeAnimation,
                  child: const Text(
                    'Cargando...',
                    style: TextStyle(
                      fontSize: 16,
                      color: Colors.black54,
                      fontWeight: FontWeight.w500)))])),
        );
      });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}

class Persona {
  final String legajo;
  final String dni;
  final String nombreCompleto;
  final String categoria;
  final String tipoPersonal;
  final String area;
  final String localidad;
  final String provincia;
  final String sexo;
  final RolPersona rol;
  final bool esDirecto;

  Persona({
    required this.legajo,
    required this.dni,
    required this.nombreCompleto,
    required this.categoria,
    required this.tipoPersonal,
    required this.area,
    required this.localidad,
    required this.provincia,
    required this.sexo,
    required this.rol,
    required this.esDirecto});
}

class Equipo {
  final String interno;
  final String tipo;
  final String marca;
  final String modelo;
  final String anio;
  final bool esVolcador;
  final String categoria;

  Equipo({
    required this.interno,
    required this.tipo,
    required this.marca,
    required this.modelo,
    required this.anio,
    required this.categoria,
  }) : esVolcador = tipo.toLowerCase().contains('volcador');
}

class Registro {
  final DateTime fecha;
  final Persona persona;
  final Equipo? equipo;
  final String actividad;
  final String horometroInicial;
  final String horometroFinal;
  final String combustible;
  final String viajes;
  final String observaciones;

  Registro({
    required this.fecha,
    required this.persona,
    this.equipo,
    required this.actividad,
    required this.horometroInicial,
    required this.horometroFinal,
    required this.combustible,
    required this.viajes,
    required this.observaciones});

  Map<String, dynamic> toMap() {
    return {
      'fecha': DateFormat('yyyy-MM-dd').format(fecha),
      'persona': persona.nombreCompleto,
      'dni': persona.dni,
      'legajo': persona.legajo,
      'categoria': persona.categoria,
      'tipo_personal': persona.tipoPersonal,
      'area': persona.area,
      'localidad': persona.localidad,
      'provincia': persona.provincia,
      'sexo': persona.sexo,
      'rol': persona.rol == RolPersona.operadorChofer ? 'Operador/Chofer' : 'Otro',
      'es_directo': persona.esDirecto,
      'interno': equipo?.interno ?? '',
      'tipo': equipo?.tipo ?? '',
      'marca': equipo?.marca ?? '',
      'modelo': equipo?.modelo ?? '',
      'anio': equipo?.anio ?? '',
      'actividad': actividad,
      'horometro_inicial': horometroInicial,
      'horometro_final': horometroFinal,
      'combustible': combustible,
      'viajes': viajes,
      'observaciones': observaciones,
      'categoria_equipo': equipo?.categoria ?? ''};
  }
}

class MainTabsScreen extends StatefulWidget {
  const MainTabsScreen({super.key});

  @override
  State<MainTabsScreen> createState() => _MainTabsScreenState();
}

class _MainTabsScreenState extends State<MainTabsScreen> {
  int _currentIndex = 0;
  final List<Widget> _tabs = [
    const ParteDiarioForm(),
    const RegistrosScreen()];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: _tabs[_currentIndex],
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndex,
        onTap: (index) {
          setState(() {
            _currentIndex = index;
          });
        },
        items: const [
          BottomNavigationBarItem(
            icon: Icon(Icons.person_add),
            label: 'Registrar'),
          BottomNavigationBarItem(
            icon: Icon(Icons.history),
            label: 'Historial')]));
  }
}

class ParteDiarioForm extends StatefulWidget {
  const ParteDiarioForm({super.key});

  @override
  State<ParteDiarioForm> createState() => _ParteDiarioFormState();
}

class _ParteDiarioFormState extends State<ParteDiarioForm> {
  final _formKey = GlobalKey<FormState>();
  final _horometroInicialController = TextEditingController();
  final _horometroFinalController = TextEditingController();
  final _combustibleController = TextEditingController();
  final _viajesController = TextEditingController();
  final _observacionesController = TextEditingController();

  String _actividad = '';
  DateTime _fechaSeleccionada = DateTime.now();
  Equipo? _equipoSeleccionado;
  List<Equipo> _equiposDisponibles = [];
  List<String> _actividadesDisponibles = [];
  double? _horometroInicial;
  double? _horometroAnterior;
  bool _isLoading = true;
  String _categoriaSeleccionada = 'EQUIPOS PESADOS';
  EnvioEstado _estadoEnvio = EnvioEstado.inicial;
  RolPersona? _rolPersonaSeleccionada;
  Persona? _personaSeleccionada;
  List<Persona> _personasDisponibles = [];
  List<Registro> _registros = [];
  List<Persona> _personasRegistradas = [];
  bool _isEditing = false;
  Registro? _registroExistente;

  final List<String> _categorias = [
    'EQUIPOS PESADOS',
    'VEHICULOS LIVIANOS - CAMIONES'
  ];

  @override
  void initState() {
    super.initState();
    _cargarDatosIniciales();
    _cargarRegistros();
  }

  Future<void> _cargarRegistros() async {
    final prefs = await SharedPreferences.getInstance();
    final registrosJson = prefs.getStringList('registros') ?? [];

    setState(() {
      _registros = registrosJson.map((json) {
        final data = jsonDecode(json);
        final persona = _personasDisponibles.firstWhere(
              (p) => p.dni == data['dni'],
          orElse: () => Persona(
            legajo: data['legajo'] ?? '',
            dni: data['dni'],
            nombreCompleto: data['persona'],
            categoria: data['categoria'] ?? '',
            tipoPersonal: data['tipo_personal'] ?? '',
            area: data['area'] ?? '',
            localidad: data['localidad'] ?? '',
            provincia: data['provincia'] ?? '',
            sexo: data['sexo'] ?? '',
            rol: data['rol'] == 'Operador/Chofer' ? RolPersona.operadorChofer : RolPersona.otro,
            esDirecto: data['es_directo'] ?? false,
          ),
        );

        return Registro(
          fecha: DateTime.parse(data['fecha']),
          persona: persona,
          actividad: data['actividad'],
          horometroInicial: data['horometro_inicial'] ?? '',
          horometroFinal: data['horometro_final'] ?? '',
          combustible: data['combustible'] ?? '',
          viajes: data['viajes'] ?? '',
          observaciones: data['observaciones'] ?? '',
        );
      }).toList();

      _personasRegistradas = _registros.map((r) => r.persona).toList();
    });
  }

  Future<void> _cargarDatosIniciales() async {
    try {
      await _cargarAsistenciaDesdeExcel();
      await _cargarEquiposDesdeExcel();
      await _cargarActividadesDesdeExcel();
      if (mounted) {
        setState(() => _isLoading = false);
      }
    } catch (e) {
      debugPrint('Error al cargar datos iniciales: $e');
      if (mounted) {
        setState(() {
          _isLoading = false;
          _actividadesDisponibles = [
            'Excavación',
            'Carga de material',
            'Compactación',
            'Riego',
            'Transporte de suelo',
            'Otro'
          ];
          _equiposDisponibles = [
            Equipo(
              interno: '101',
              tipo: 'Camion Volcador',
              marca: 'Mercedes-Benz',
              modelo: 'Atego 1726',
              anio: '2019',
              categoria: 'EQUIPOS PESADOS'),
            Equipo(
              interno: 'VH-001',
              tipo: 'Camioneta',
              marca: 'Toyota',
              modelo: 'Hilux',
              anio: '2020',
              categoria: 'VEHICULOS LIVIANOS - CAMIONES')];
          _personasDisponibles = [
            Persona(
              legajo: '123',
              dni: '12345678',
              nombreCompleto: 'Juan Pérez',
              categoria: 'Oficial',
              tipoPersonal: 'Operador',
              area: 'Producción',
              localidad: 'Localidad',
              provincia: 'Provincia',
              sexo: 'Masculino',
              rol: RolPersona.operadorChofer,
              esDirecto: true),
            Persona(
              legajo: '456',
              dni: '87654321',
              nombreCompleto: 'Carlos Gómez',
              categoria: 'Ayudante',
              tipoPersonal: 'Otro',
              area: 'SSGG',
              localidad: 'Localidad',
              provincia: 'Provincia',
              sexo: 'Masculino',
              rol: RolPersona.otro,
              esDirecto: true)]});
      }
    }
  }

  Future<void> _cargarAsistenciaDesdeExcel() async {
    final data = await rootBundle.load('assets/Asistencia_Diaria.xlsx');
    final excel = Excel.decodeBytes(data.buffer.asUint8List());
    final sheet = excel.tables['Hoja1']!;

    setState(() {
      _personasDisponibles = sheet.rows.skip(1).map((row) => Persona(
        legajo: row[0]?.value.toString() ?? '',
        dni: row[1]?.value.toString() ?? '',
        nombreCompleto: row[2]?.value.toString() ?? '',
        categoria: row[3]?.value.toString() ?? '',
        tipoPersonal: row[4]?.value.toString() ?? '',
        area: row[5]?.value.toString() ?? '',
        localidad: row[6]?.value.toString() ?? '',
        provincia: row[7]?.value.toString() ?? '',
        sexo: row[8]?.value.toString() ?? '',
        rol: row[3]?.value.toString()?.contains('Oficial') ?? false
            ? RolPersona.operadorChofer
            : RolPersona.otro,
        esDirecto: row[4]?.value.toString() == 'Directo',
      )).toList();
    });
  }

  Future<void> _cargarEquiposDesdeExcel() async {
    try {
      final ByteData data = await rootBundle.load('assets/Base_de_Equipos.xlsx');
      final Uint8List bytes = data.buffer.asUint8List();
      final excel = Excel.decodeBytes(bytes);
      _equiposDisponibles = [];

      if (excel.tables.containsKey('EQUIPOS PESADOS')) {
        final sheet = excel.tables['EQUIPOS PESADOS']!;
        for (int i = 1; i < sheet.rows.length; i++) {
          final row = sheet.rows[i];
          if (row.length > 11) {
            _equiposDisponibles.add(Equipo(
              interno: _obtenerValorCelda(row[2]),
              tipo: _obtenerValorCelda(row[11]),
              marca: _obtenerValorCelda(row[4]),
              modelo: _obtenerValorCelda(row[5]),
              anio: _obtenerValorCelda(row[6]),
              categoria: 'EQUIPOS PESADOS'));
          }
        }
      }

      if (excel.tables.containsKey('VEHICULOS LIVIANOS - CAMIONES')) {
        final sheet = excel.tables['VEHICULOS LIVIANOS - CAMIONES']!;
        for (int i = 1; i < sheet.rows.length; i++) {
          final row = sheet.rows[i];
          if (row.length > 10) {
            _equiposDisponibles.add(Equipo(
              interno: _obtenerValorCelda(row[2]),
              tipo: _obtenerValorCelda(row[9]),
              marca: _obtenerValorCelda(row[10]),
              modelo: _obtenerValorCelda(row[3]),
              anio: _obtenerValorCelda(row[4]),
              categoria: 'VEHICULOS LIVIANOS - CAMIONES'));
          }
        }
      }
    } catch (e) {
      debugPrint('Error al cargar equipos: $e');
      rethrow;
    }
  }

  Future<void> _cargarActividadesDesdeExcel() async {
    try {
      final ByteData data = await rootBundle.load('assets/Itemizado_Obra.xlsx');
      final Uint8List bytes = data.buffer.asUint8List();
      final excel = Excel.decodeBytes(bytes);

      if (excel.tables.containsKey('ACTIVIDADES')) {
        final sheet = excel.tables['ACTIVIDADES']!;
        _actividadesDisponibles = [];

        for (int i = 1; i < sheet.rows.length; i++) {
          final row = sheet.rows[i];
          if (row.isNotEmpty && row[0] != null) {
            _actividadesDisponibles.add(_obtenerValorCelda(row[0]));
          }
        }
      }
    } catch (e) {
      debugPrint('Error al cargar actividades: $e');
      rethrow;
    }
  }

  String _obtenerValorCelda(dynamic celda) {
    return celda?.value?.toString().trim() ?? '';
  }

  Future<void> _cargarHorometros() async {
    if (_equipoSeleccionado == null) return;

    final prefs = await SharedPreferences.getInstance();

    final fechaAnterior = _fechaSeleccionada.subtract(const Duration(days: 1));
    final fechaAnteriorStr = DateFormat('yyyy-MM-dd').format(fechaAnterior);
    final horometroAnterior = prefs.getDouble('horometro_${_equipoSeleccionado?.interno}_$fechaAnteriorStr');

    final fechaStr = DateFormat('yyyy-MM-dd').format(_fechaSeleccionada);
    final horometroGuardado = prefs.getDouble('horometro_${_equipoSeleccionado?.interno}_$fechaStr');

    if (mounted) {
      setState(() {
        _horometroAnterior = horometroAnterior;
        _horometroInicial = horometroGuardado;
        if (_horometroInicial != null) {
          _horometroInicialController.text = _horometroInicial!.toStringAsFixed(2);
        } else {
          _horometroInicialController.clear();
        }
      });
    }
  }

  Future<void> _guardarHorometroFinal() async {
    if (_equipoSeleccionado == null || _horometroFinalController.text.isEmpty) return;

    final fechaStr = DateFormat('yyyy-MM-dd').format(_fechaSeleccionada);
    final prefs = await SharedPreferences.getInstance();
    await prefs.setDouble(
      'horometro_${_equipoSeleccionado?.interno}_$fechaStr',
      double.parse(_horometroFinalController.text));
  }

  Future<void> _guardarRegistro() async {
    if (!_formKey.currentState!.validate()) return;
    if (_personaSeleccionada == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Debe seleccionar una persona'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(12)))));
      return;
    }

    if (_rolPersonaSeleccionada == RolPersona.operadorChofer &&
        (_equipoSeleccionado == null || _horometroFinalController.text.isEmpty)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Para operadores/choferes, complete todos los campos obligatorios'),
          behavior: SnackBarBehavior.floating,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.all(Radius.circular(12)))));
      return;
    }

    setState(() => _estadoEnvio = EnvioEstado.enviando);

    try {
      final registro = Registro(
        fecha: _fechaSeleccionada,
        persona: _personaSeleccionada!,
        equipo: _equipoSeleccionado,
        actividad: _actividad,
        horometroInicial: _horometroInicialController.text,
        horometroFinal: _horometroFinalController.text,
        combustible: _combustibleController.text.isNotEmpty
            ? _combustibleController.text
            : '0',
        viajes: (_equipoSeleccionado?.esVolcador ?? false)
            ? _viajesController.text
            : '0',
        observaciones: _observacionesController.text);

      final prefs = await SharedPreferences.getInstance();
      final registros = prefs.getStringList('registros') ?? [];
      
      if (_isEditing && _registroExistente != null) {
        // Actualizar registro existente
        final index = registros.indexWhere((r) {
          final data = jsonDecode(r);
          return data['dni'] == _registroExistente!.persona.dni && 
                 data['fecha'] == DateFormat('yyyy-MM-dd').format(_registroExistente!.fecha);
        });
        if (index != -1) {
          registros[index] = jsonEncode(registro.toMap());
        }
      } else {
        // Agregar nuevo registro
        registros.add(jsonEncode(registro.toMap()));
      }
      
      await prefs.setStringList('registros', registros);

      if (_rolPersonaSeleccionada == RolPersona.operadorChofer) {
        await _guardarHorometroFinal();
      }

      _mostrarDialogoExito();
      _limpiarFormulario();
      await _cargarRegistros();
    } catch (e) {
      debugPrint('Error al guardar registro: $e');
      setState(() => _estadoEnvio = EnvioEstado.fallido);
      _mostrarDialogoError('Error al guardar: $e');
    } finally {
      if (mounted) {
        setState(() {
          _estadoEnvio = EnvioEstado.inicial;
          _isEditing = false;
        });
      }
    }
  }

  Future<void> _exportarAExcel() async {
    try {
      setState(() => _estadoEnvio = EnvioEstado.enviando);

      final excel = Excel.createExcel();
      final sheet = excel['Registros'];

      // Encabezados
      sheet.appendRow([
        'Fecha',
        'Persona',
        'DNI',
        'Rol',
        'Interno',
        'Tipo',
        'Marca',
        'Modelo',
        'Año',
        'Actividad',
        'Horómetro Inicial',
        'Horómetro Final',
        'Combustible',
        'Viajes',
        'Observaciones',
        'Categoría']);

      // Datos
      for (final registro in _registros) {
        sheet.appendRow([
          DateFormat('yyyy-MM-dd').format(registro.fecha),
          registro.persona.nombreCompleto,
          registro.persona.dni,
          registro.persona.rol == RolPersona.operadorChofer ? 'Operador/Chofer' : 'Otro',
          registro.equipo?.interno ?? '',
          registro.equipo?.tipo ?? '',
          registro.equipo?.marca ?? '',
          registro.equipo?.modelo ?? '',
          registro.equipo?.anio ?? '',
          registro.actividad,
          registro.horometroInicial,
          registro.horometroFinal,
          registro.combustible,
          registro.viajes,
          registro.observaciones,
          registro.equipo?.categoria ?? '']);
      }

      // Guardar archivo
      final directory = await getApplicationDocumentsDirectory();
      final filePath = '${directory.path}/registros_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.xlsx';
      final file = File(filePath);
      await file.writeAsBytes(excel.encode()!);

      setState(() => _estadoEnvio = EnvioEstado.exitoso);

      // Mostrar diálogo de éxito
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Exportación exitosa'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('El archivo Excel se ha generado correctamente.'),
              const SizedBox(height: 16),
              Text('Ubicación: $filePath')],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cerrar')),
            TextButton(
              onPressed: () async {
                Navigator.pop(context);
                if (await File(filePath).exists()) {
                  await Process.run('start', [filePath], runInShell: true);
                }
              },
              child: const Text('Abrir archivo'))]));
    } catch (e) {
      debugPrint('Error al exportar a Excel: $e');
      setState(() => _estadoEnvio = EnvioEstado.fallido);
      _mostrarDialogoError('Error al exportar: $e');
    }
  }

  void _mostrarDialogoExito() {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(_isEditing ? 'Registro Actualizado' : 'Registro Guardado', 
               style: const TextStyle(color: Color(0xFF0D47A1))),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(_isEditing 
                ? 'Los datos se han actualizado correctamente:' 
                : 'Los datos se han registrado correctamente:'),
            const SizedBox(height: 16),
            Text('Persona: ${_personaSeleccionada?.nombreCompleto}'),
            if (_rolPersonaSeleccionada == RolPersona.operadorChofer) ...[
              Text('Equipo: ${_equipoSeleccionado?.interno}'),
              Text('Horómetro Final: ${_horometroFinalController.text}')]])),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Aceptar'))]));
  }

  void _mostrarDialogoError(String error) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Error al Guardar', style: TextStyle(color: Colors.red)),
        content: Text('Ocurrió un error al guardar el registro: $error'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Entendido'))]));
  }

  void _mostrarConfirmacion() {
    if (_formKey.currentState!.validate()) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: Text(_isEditing ? 'Confirmar Actualización' : 'Confirmar Registro', 
                 style: const TextStyle(color: Color(0xFF0D47A1))),
          content: Text(_isEditing 
              ? '¿Está seguro que desea actualizar estos datos?' 
              : '¿Está seguro que desea registrar estos datos?'),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancelar')),
            ElevatedButton(
              onPressed: () async {
                Navigator.pop(context);
                await _guardarRegistro();
              },
              child: Text(_isEditing ? 'Actualizar' : 'Registrar'))]));
    }
  }

  void _limpiarFormulario() {
    _formKey.currentState?.reset();
    _horometroInicialController.clear();
    _horometroFinalController.clear();
    _combustibleController.clear();
    _viajesController.clear();
    _observacionesController.clear();
    if (mounted) {
      setState(() {
        _personaSeleccionada = null;
        _rolPersonaSeleccionada = null;
        _equipoSeleccionado = null;
        _actividad = '';
        _horometroInicial = null;
        _horometroAnterior = null;
        _fechaSeleccionada = DateTime.now();
        _isEditing = false;
        _registroExistente = null;
      });
    }
  }

  void _habilitarEdicion() {
    setState(() {
      _isEditing = true;
    });
  }

  void _cargarDatosParaEdicion(Registro registro) {
    setState(() {
      _personaSeleccionada = registro.persona;
      _rolPersonaSeleccionada = registro.persona.rol;
      _actividad = registro.actividad;
      _horometroInicialController.text = registro.horometroInicial;
      _horometroFinalController.text = registro.horometroFinal;
      _combustibleController.text = registro.combustible;
      _viajesController.text = registro.viajes;
      _observacionesController.text = registro.observaciones;
      _fechaSeleccionada = registro.fecha;
      _registroExistente = registro;
      
      // Buscar el equipo si existe
      if (registro.equipo != null) {
        _equipoSeleccionado = _equiposDisponibles.firstWhere(
          (e) => e.interno == registro.equipo?.interno,
          orElse: () => registro.equipo!);
        _categoriaSeleccionada = registro.equipo!.categoria;
      }
    });
  }

  Widget _buildDetailRow(String label, String value, {bool isImportant = false}) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 4),
      child: Row(
        children: [
          Text(
            '$label: ',
            style: TextStyle(
              fontWeight: FontWeight.w500,
              color: Colors.grey.shade700)),
          Text(
            value,
            style: TextStyle(
              fontWeight: isImportant ? FontWeight.bold : FontWeight.normal,
              color: isImportant ? const Color(0xFF0D47A1) : Colors.black))]));
  }

  DateTime _fechaSeleccionadaSinHora() {
    final now = DateTime.now();
    return DateTime(now.year, now.month, now.day);
  }

  bool _personaYaRegistrada() {
    if (_personaSeleccionada == null) return false;
    return _personasRegistradas.any((p) => p.dni == _personaSeleccionada!.dni);
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Image.asset('assets/logo.png', width: 150, height: 150, errorBuilder: (context, error, stackTrace) {
                return const Icon(Icons.construction, size: 100, color: Colors.blue);
              }),
              const SizedBox(height: 24),
              const CircularProgressIndicator(
                valueColor: AlwaysStoppedAnimation<Color>(Color(0xFF0D47A1))]));
    }

    final bool isOperadorChofer = _rolPersonaSeleccionada == RolPersona.operadorChofer;
    final bool personaRegistrada = _personaYaRegistrada() && !_isEditing;

    return Stack(
      children: [
        Scaffold(
          appBar: AppBar(
            title: Row(
              children: [
                Image.asset('assets/logo.png', height: 40, errorBuilder: (context, error, stackTrace) {
                  return const Icon(Icons.construction, color: Colors.white);
                }),
                const SizedBox(width: 12),
                const Text('Registro de Personal',
                    style: TextStyle(fontWeight: FontWeight.bold))],
            backgroundColor: const Color(0xFF0D47A1),
            actions: [
              IconButton(
                icon: const Icon(Icons.refresh),
                onPressed: _limpiarFormulario,
                tooltip: 'Nuevo Registro')]),
          body: Container(
            decoration: const BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: [Color(0xFFF5F9FF), Color(0xFFE3F2FD)])),
            child: SingleChildScrollView(
              padding: const EdgeInsets.all(20),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Fecha del Registro',
                              style: Theme.of(context).textTheme.titleLarge),
                            const SizedBox(height: 12),
                            DropdownButtonFormField<int>(
                              value: _fechaSeleccionadaSinHora().millisecondsSinceEpoch,
                              items: List.generate(7, (index) {
                                final date = _fechaSeleccionadaSinHora().add(Duration(days: index - 3));
                                return DropdownMenuItem<int>(
                                  value: date.millisecondsSinceEpoch,
                                  child: Text(DateFormat('dd/MM/yyyy').format(date)));
                              }),
                              onChanged: personaRegistrada 
                                  ? null 
                                  : (int? newValue) {
                                      if (newValue != null) {
                                        setState(() {
                                          _fechaSeleccionada = DateTime.fromMillisecondsSinceEpoch(newValue);
                                        });
                                      }
                                    })])),
                    const SizedBox(height: 16),

                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Datos de la Persona',
                              style: Theme.of(context).textTheme.titleLarge),
                            const SizedBox(height: 12),
                            DropdownButtonFormField<Persona>(
                              value: _personaSeleccionada,
                              decoration: const InputDecoration(
                                labelText: 'Personal Directo',
                                border: OutlineInputBorder()),
                              items: _personasDisponibles
                                  .where((p) => p.tipoPersonal == 'Directo')
                                  .map((p) => DropdownMenuItem<Persona>(
                                value: p,
                                child: Text(
                                  p.nombreCompleto,
                                  style: TextStyle(
                                    color: _personasRegistradas.any((reg) => reg.dni == p.dni)
                                        ? Colors.green
                                        : Theme.of(context).textTheme.bodyLarge?.color,
                                    fontWeight: _personasRegistradas.any((reg) => reg.dni == p.dni)
                                        ? FontWeight.bold
                                        : FontWeight.normal)))),
                              onChanged: personaRegistrada
                                  ? null
                                  : (value) {
                                      setState(() {
                                        _personaSeleccionada = value;
                                        if (value != null) {
                                          // Buscar si ya existe un registro para esta persona
                                          final registroExistente = _registros.firstWhere(
                                            (r) => r.persona.dni == value.dni && 
                                                  DateFormat('yyyy-MM-dd').format(r.fecha) == 
                                                  DateFormat('yyyy-MM-dd').format(_fechaSeleccionada),
                                            orElse: () => Registro(
                                              fecha: DateTime.now(),
                                              persona: Persona(
                                                legajo: '',
                                                dni: '',
                                                nombreCompleto: '',
                                                categoria: '',
                                                tipoPersonal: '',
                                                area: '',
                                                localidad: '',
                                                provincia: '',
                                                sexo: '',
                                                rol: RolPersona.otro,
                                                esDirecto: false),
                                              actividad: '',
                                              horometroInicial: '',
                                              horometroFinal: '',
                                              combustible: '',
                                              viajes: '',
                                              observaciones: ''));

                                          if (registroExistente.persona.dni.isNotEmpty) {
                                            _cargarDatosParaEdicion(registroExistente);
                                          }
                                        }
                                      });
                                    }),
                            if (_personaSeleccionada != null) ...[
                              const SizedBox(height: 16),
                              Card(
                                child: Padding(
                                  padding: const EdgeInsets.all(16),
                                  child: Column(
                                    crossAxisAlignment: CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        'Detalles del Personal',
                                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                                          color: const Color(0xFF0D47A1),
                                          fontWeight: FontWeight.bold)),
                                      const SizedBox(height: 8),
                                      _buildDetailRow('Legajo', _personaSeleccionada!.legajo),
                                      _buildDetailRow('DNI', _personaSeleccionada!.dni),
                                      _buildDetailRow('Categoría', _personaSeleccionada!.categoria),
                                      _buildDetailRow('Tipo', _personaSeleccionada!.tipoPersonal),
                                      _buildDetailRow('Área', _personaSeleccionada!.area),
                                      _buildDetailRow('Localidad', _personaSeleccionada!.localidad),
                                      _buildDetailRow('Provincia', _personaSeleccionada!.provincia),
                                      _buildDetailRow('Sexo', _personaSeleccionada!.sexo)])),
                              const SizedBox(height: 12),
                              Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  const Text('Rol de la persona:'),
                                  RadioListTile<RolPersona>(
                                    title: const Text('Operador de equipo/Chofer'),
                                    value: RolPersona.operadorChofer,
                                    groupValue: _rolPersonaSeleccionada,
                                    onChanged: personaRegistrada
                                        ? null
                                        : (RolPersona? value) {
                                            setState(() {
                                              _rolPersonaSeleccionada = value;
                                              if (value != RolPersona.operadorChofer) {
                                                _equipoSeleccionado = null;
                                              }
                                            });
                                          }),
                                  RadioListTile<RolPersona>(
                                    title: const Text('Otro'),
                                    value: RolPersona.otro,
                                    groupValue: _rolPersonaSeleccionada,
                                    onChanged: personaRegistrada
                                        ? null
                                        : (RolPersona? value) {
                                            setState(() {
                                              _rolPersonaSeleccionada = value;
                                              if (value == RolPersona.otro) {
                                                _equipoSeleccionado = null;
                                              }
                                            });
                                          })])])])),
                    const SizedBox(height: 16),

                    if (isOperadorChofer || _rolPersonaSeleccionada == null)
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Datos del Equipo',
                                style: Theme.of(context).textTheme.titleLarge),
                              const SizedBox(height: 12),
                              isOperadorChofer
                                  ? Column(
                                      children: [
                                        DropdownButtonFormField<String>(
                                          value: _categoriaSeleccionada,
                                          decoration: const InputDecoration(
                                            labelText: 'Categoría del Equipo',
                                            prefixIcon: Icon(Icons.category, color: Color(0xFF0D47A1))),
                                          items: _categorias.map((String categoria) {
                                            return DropdownMenuItem<String>(
                                              value: categoria,
                                              child: Text(categoria));
                                          }).toList(),
                                          onChanged: personaRegistrada
                                              ? null
                                              : (String? newValue) {
                                                  setState(() {
                                                    _categoriaSeleccionada = newValue!;
                                                    _equipoSeleccionado = null;
                                                  });
                                                }),
                                        const SizedBox(height: 12),
                                        Autocomplete<Equipo>(
                                          optionsBuilder: (TextEditingValue textEditingValue) {
                                            final equiposFiltrados = _equiposDisponibles
                                                .where((equipo) => equipo.categoria == _categoriaSeleccionada)
                                                .toList();
                                            if (textEditingValue.text.isEmpty) {
                                              return equiposFiltrados;
                                            }
                                            return equiposFiltrados.where((equipo) =>
                                                equipo.interno.toLowerCase().contains(textEditingValue.text.toLowerCase()) ||
                                                '${equipo.marca} ${equipo.modelo}'.toLowerCase().contains(textEditingValue.text.toLowerCase()));
                                          },
                                          onSelected: personaRegistrada
                                              ? null
                                              : (Equipo equipo) async {
                                                  setState(() => _equipoSeleccionado = equipo);
                                                  await _cargarHorometros();
                                                },
                                          displayStringForOption: (equipo) => '${equipo.interno} - ${equipo.marca} ${equipo.modelo}',
                                          fieldViewBuilder: (context, controller, focusNode, onEditingComplete) {
                                            return TextFormField(
                                              controller: controller,
                                              focusNode: focusNode,
                                              decoration: const InputDecoration(
                                                labelText: 'N° Interno del Equipo',
                                                prefixIcon: Icon(Icons.search, color: Color(0xFF0D47A1))),
                                              enabled: !personaRegistrada,
                                              validator: isOperadorChofer
                                                  ? (value) => value == null || value.isEmpty ? 'Seleccione un equipo válido' : null
                                                  : null);
                                          })])
                                  : Opacity(
                                      opacity: 0.6,
                                      child: IgnorePointer(
                                        child: Column(
                                          children: [
                                            DropdownButtonFormField<String>(
                                              value: _categoriaSeleccionada,
                                              decoration: const InputDecoration(
                                                labelText: 'Categoría del Equipo (solo para operadores)',
                                                prefixIcon: Icon(Icons.category, color: Colors.grey))),
                                              items: _categorias.map((String categoria) {
                                                return DropdownMenuItem<String>(
                                                  value: categoria,
                                                  child: Text(categoria));
                                              }).toList(),
                                              onChanged: null),
                                            const SizedBox(height: 12),
                                            TextFormField(
                                              decoration: const InputDecoration(
                                                labelText: 'N° Interno del Equipo (solo para operadores)',
                                                prefixIcon: Icon(Icons.search, color: Colors.grey))),
                                              enabled: false)])),
                            if (_equipoSeleccionado != null) ...[
                              const SizedBox(height: 12),
                              Container(
                                padding: const EdgeInsets.all(16),
                                decoration: BoxDecoration(
                                  color: Colors.blue.shade50,
                                  borderRadius: BorderRadius.circular(12)),
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      _equipoSeleccionado!.tipo,
                                      style: const TextStyle(
                                        fontSize: 16,
                                        fontWeight: FontWeight.bold)),
                                    const SizedBox(height: 8),
                                    _buildDetailRow('Marca', _equipoSeleccionado!.marca),
                                    _buildDetailRow('Modelo', _equipoSeleccionado!.modelo),
                                    _buildDetailRow('Año', _equipoSeleccionado!.anio),
                                    _buildDetailRow('Categoría', _equipoSeleccionado!.categoria)])])])),
                    const SizedBox(height: 16),

                    if (isOperadorChofer || _rolPersonaSeleccionada == null)
                      Card(
                        child: Padding(
                          padding: const EdgeInsets.all(16),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Text(
                                'Control de Combustible y Horómetro',
                                style: Theme.of(context).textTheme.titleLarge),
                              const SizedBox(height: 12),
                              isOperadorChofer
                                  ? Column(
                                      children: [
                                        TextFormField(
                                          controller: _horometroInicialController,
                                          decoration: const InputDecoration(
                                            labelText: 'Horómetro Inicial',
                                            prefixIcon: Icon(Icons.speed, color: Color(0xFF0D47A1))),
                                          enabled: !personaRegistrada,
                                          keyboardType: TextInputType.number,
                                          inputFormatters: [
                                            FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d{0,2}'))],
                                          validator: isOperadorChofer
                                              ? (value) {
                                                  if (value == null || value.isEmpty) {
                                                    return 'Ingrese el horómetro inicial';
                                                  }
                                                  return null;
                                                }
                                              : null),
                                        const SizedBox(height: 8),
                                        _horometroAnterior != null
                                            ? Text(
                                                'Horómetro anterior (${DateFormat('dd/MM').format(_fechaSeleccionada.subtract(const Duration(days: 1)))}): ${_horometroAnterior!.toStringAsFixed(2)}',
                                                style: const TextStyle(color: Colors.blue))
                                            : const Text(
                                                'No existe horómetro registrado anteriormente',
                                                style: TextStyle(color: Colors.grey)),
                                        const SizedBox(height: 16),
                                        TextFormField(
                                          controller: _combustibleController,
                                          decoration: const InputDecoration(
                                            labelText: 'Combustible Cargado (litros)',
                                            prefixIcon: Icon(Icons.local_gas_station, color: Color(0xFF0D47A1)),
                                            hintText: 'Opcional - Dejar vacío si no se cargó')),
                                          enabled: !personaRegistrada,
                                          keyboardType: TextInputType.number,
                                          inputFormatters: [
                                            FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d{0,2}'))]),
                                        const SizedBox(height: 16),
                                        TextFormField(
                                          controller: _horometroFinalController,
                                          decoration: const InputDecoration(
                                            labelText: 'Horómetro Final',
                                            prefixIcon: Icon(Icons.speed, color: Color(0xFF0D47A1))),
                                          enabled: !personaRegistrada,
                                          keyboardType: TextInputType.number,
                                          inputFormatters: [
                                            FilteringTextInputFormatter.allow(RegExp(r'^\d*\.?\d{0,2}'))],
                                          validator: isOperadorChofer
                                              ? (value) {
                                                  if (value == null || value.isEmpty) {
                                                    return 'Registre el horómetro al finalizar';
                                                  }
                                                  if (double.tryParse(_horometroInicialController.text) != null &&
                                                      double.tryParse(value)! < double.parse(_horometroInicialController.text)) {
                                                    return 'El horómetro final no puede ser menor al inicial';
                                                  }
                                                  return null;
                                                }
                                              : null)])
                                  : Opacity(
                                      opacity: 0.6,
                                      child: IgnorePointer(
                                        child: Column(
                                          children: [
                                            TextFormField(
                                              decoration: const InputDecoration(
                                                labelText: 'Horómetro Inicial (solo para operadores)',
                                                prefixIcon: Icon(Icons.speed, color: Colors.grey))),
                                              enabled: false),
                                            const SizedBox(height: 16),
                                            TextFormField(
                                              decoration: const InputDecoration(
                                                labelText: 'Combustible Cargado (solo para operadores)',
                                                prefixIcon: Icon(Icons.local_gas_station, color: Colors.grey))),
                                              enabled: false),
                                            const SizedBox(height: 16),
                                            TextFormField(
                                              decoration: const InputDecoration(
                                                labelText: 'Horómetro Final (solo para operadores)',
                                                prefixIcon: Icon(Icons.speed, color: Colors.grey))),
                                              enabled: false)])])),
                    const SizedBox(height: 16),

                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Registro de Actividad',
                              style: Theme.of(context).textTheme.titleLarge),
                            const SizedBox(height: 12),
                            DropdownButtonFormField<String>(
                              decoration: const InputDecoration(
                                labelText: 'Actividad Realizada',
                                prefixIcon: Icon(Icons.construction, color: Color(0xFF0D47A1))),
                              value: _actividad.isNotEmpty ? _actividad : null,
                              items: _actividadesDisponibles
                                  .map((a) => DropdownMenuItem(
                                        value: a,
                                        child: Text(a)))
                                  .toList(),
                              onChanged: personaRegistrada
                                  ? null
                                  : (val) {
                                      if (mounted) {
                                        setState(() => _actividad = val ?? '');
                                      }
                                    },
                              validator: (val) =>
                                  val == null || val.isEmpty ? 'Seleccione una actividad' : null),
                            const SizedBox(height: 12),
                            if (isOperadorChofer && (_equipoSeleccionado?.esVolcador ?? false)) ...[
                              TextFormField(
                                controller: _viajesController,
                                decoration: const InputDecoration(
                                  labelText: 'Cantidad de Viajes (Opcional)',
                                  prefixIcon: Icon(Icons.local_shipping, color: Color(0xFF0D47A1))),
                                enabled: !personaRegistrada,
                                keyboardType: TextInputType.number,
                                inputFormatters: [FilteringTextInputFormatter.digitsOnly]),
                              const SizedBox(height: 12)]])),
                    const SizedBox(height: 16),

                    Card(
                      child: Padding(
                        padding: const EdgeInsets.all(16),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            Text(
                              'Observaciones',
                              style: Theme.of(context).textTheme.titleLarge),
                            const SizedBox(height: 12),
                            TextFormField(
                              controller: _observacionesController,
                              decoration: const InputDecoration(
                                labelText: 'Detalles adicionales (paradas, problemas, etc.)',
                                prefixIcon: Icon(Icons.note, color: Color(0xFF0D47A1))),
                              enabled: !personaRegistrada,
                              maxLines: 3,
                              keyboardType: TextInputType.multiline)])),
                    const SizedBox(height: 24),

                    if (personaRegistrada)
                      ElevatedButton(
                        onPressed: _habilitarEdicion,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFFFFC107),
                          padding: const EdgeInsets.symmetric(vertical: 18),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12)),
                          elevation: 2,
                          shadowColor: Colors.amber.withOpacity(0.3)),
                        child: const Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.edit, color: Colors.black),
                            SizedBox(width: 12),
                            Text(
                              'EDITAR REGISTRO',
                              style: TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.bold,
                                color: Colors.black))])),
                    if (!personaRegistrada || _isEditing)
                      ElevatedButton(
                        onPressed: _mostrarConfirmacion,
                        style: ElevatedButton.styleFrom(
                          backgroundColor: const Color(0xFF0D47A1),
                          padding: const EdgeInsets.symmetric(vertical: 18),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12)),
                          elevation: 2,
                          shadowColor: Colors.blue.withOpacity(0.3)),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            const Icon(Icons.save, color: Colors.white),
                            const SizedBox(width: 12),
                            Text(
                              _isEditing ? 'ACTUALIZAR' : 'REGISTRAR',
                              style: const TextStyle(
                                fontSize: 16,
                                fontWeight: FontWeight.bold)))])),
                    const SizedBox(height: 12),
                    OutlinedButton(
                      onPressed: _registros.isNotEmpty ? _exportarAExcel : null,
                      style: OutlinedButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 18),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12)),
                        side: const BorderSide(color: Color(0xFF0D47A1))),
                      child: const Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Icon(Icons.file_download, color: Color(0xFF0D47A1)),
                          SizedBox(width: 12),
                          Text(
                            'EXPORTAR A EXCEL',
                            style: TextStyle(
                              fontSize: 16,
                              fontWeight: FontWeight.bold,
                              color: Color(0xFF0D47A1)))])),
                  ]))),
        if (_estadoEnvio == EnvioEstado.enviando)
          Container(
            color: Colors.black.withOpacity(0.5),
            child: Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const CircularProgressIndicator(
                    valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                    strokeWidth: 4),
                  const SizedBox(height: 20),
                  Text(
                    _estadoEnvio == EnvioEstado.enviando
                        ? 'Guardando datos...'
                        : 'Generando archivo...',
                    style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                      color: Colors.white))]))));
  }

  @override
  void dispose() {
    _horometroInicialController.dispose();
    _horometroFinalController.dispose();
    _combustibleController.dispose();
    _viajesController.dispose();
    _observacionesController.dispose();
    super.dispose();
  }
}

class RegistrosScreen extends StatefulWidget {
  const RegistrosScreen({super.key});

  @override
  State<RegistrosScreen> createState() => _RegistrosScreenState();
}

class _RegistrosScreenState extends State<RegistrosScreen> {
  List<Registro> _registros = [];
  bool _isLoading = true;

  @override
  void initState() {
    super.initState();
    _cargarRegistros();
  }

  Future<void> _cargarRegistros() async {
    final prefs = await SharedPreferences.getInstance();
    final registrosJson = prefs.getStringList('registros') ?? [];

    setState(() {
      _registros = registrosJson.map((json) {
        final data = jsonDecode(json);
        return Registro(
          fecha: DateTime.parse(data['fecha']),
          persona: Persona(
            legajo: data['legajo'] ?? '',
            dni: data['dni'],
            nombreCompleto: data['persona'],
            categoria: data['categoria'] ?? '',
            tipoPersonal: data['tipo_personal'] ?? '',
            area: data['area'] ?? '',
            localidad: data['localidad'] ?? '',
            provincia: data['provincia'] ?? '',
            sexo: data['sexo'] ?? '',
            rol: data['rol'] == 'Operador/Chofer' ? RolPersona.operadorChofer : RolPersona.otro,
            esDirecto: data['es_directo'] ?? false,
          ),
          actividad: data['actividad'],
          horometroInicial: data['horometro_inicial'] ?? '',
          horometroFinal: data['horometro_final'] ?? '',
          combustible: data['combustible'] ?? '',
          viajes: data['viajes'] ?? '',
          observaciones: data['observaciones'] ?? '',
        );
      }).toList();
      _isLoading = false;
    });
  }

  Future<void> _exportarAExcel() async {
    try {
      final excel = Excel.createExcel();
      final sheet = excel['Registros'];

      // Encabezados
      sheet.appendRow([
        'Fecha',
        'Persona',
        'DNI',
        'Rol',
        'Interno',
        'Tipo',
        'Marca',
        'Modelo',
        'Año',
        'Actividad',
        'Horómetro Inicial',
        'Horómetro Final',
        'Combustible',
        'Viajes',
        'Observaciones']);

      // Datos
      for (final registro in _registros) {
        sheet.appendRow([
          DateFormat('yyyy-MM-dd').format(registro.fecha),
          registro.persona.nombreCompleto,
          registro.persona.dni,
          registro.persona.rol == RolPersona.operadorChofer ? 'Operador/Chofer' : 'Otro',
          registro.equipo?.interno ?? '',
          registro.equipo?.tipo ?? '',
          registro.equipo?.marca ?? '',
          registro.equipo?.modelo ?? '',
          registro.equipo?.anio ?? '',
          registro.actividad,
          registro.horometroInicial,
          registro.horometroFinal,
          registro.combustible,
          registro.viajes,
          registro.observaciones]);
      }

      // Guardar archivo
      final directory = await getApplicationDocumentsDirectory();
      final filePath = '${directory.path}/registros_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now())}.xlsx';
      final file = File(filePath);
      await file.writeAsBytes(excel.encode()!);

      // Mostrar diálogo de éxito
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Exportación exitosa'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('El archivo Excel se ha generado correctamente.'),
              const SizedBox(height: 16),
              Text('Ubicación: $filePath')]),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cerrar')),
            TextButton(
              onPressed: () async {
                Navigator.pop(context);
                if (await File(filePath).exists()) {
                  await Process.run('start', [filePath], runInShell: true);
                }
              },
              child: const Text('Abrir archivo'))]));
    } catch (e) {
      debugPrint('Error al exportar a Excel: $e');
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text('Error al exportar: $e'),
          backgroundColor: Colors.red));
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(
        child: CircularProgressIndicator());
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Historial de Registros'),
        actions: [
          IconButton(
            icon: const Icon(Icons.file_download),
            onPressed: _exportarAExcel,
            tooltip: 'Exportar a Excel')]),
      body: _registros.isEmpty
          ? const Center(
              child: Text('No hay registros guardados'))
          : ListView.builder(
              itemCount: _registros.length,
              itemBuilder: (context, index) {
                final registro = _registros[index];
                return Card(
                  margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  child: Padding(
                    padding: const EdgeInsets.all(16),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          registro.persona.nombreCompleto,
                          style: const TextStyle(
                            fontWeight: FontWeight.bold,
                            fontSize: 18)),
                        const SizedBox(height: 8),
                        Text(
                          'Fecha: ${DateFormat('dd/MM/yyyy').format(registro.fecha)}',
                          style: const TextStyle(color: Colors.grey)),
                        const SizedBox(height: 8),
                        Text('Actividad: ${registro.actividad}'),
                        if (registro.equipo != null) ...[
                          const SizedBox(height: 8),
                          Text('Equipo: ${registro.equipo!.interno} - ${registro.equipo!.tipo}')],
                        if (registro.horometroFinal.isNotEmpty) ...[
                          const SizedBox(height: 8),
                          Text('Horómetro Final: ${registro.horometroFinal}')],
                        if (registro.observaciones.isNotEmpty) ...[
                          const SizedBox(height: 8),
                          Text('Observaciones: ${registro.observaciones}')]]));
              }));
  }
}
